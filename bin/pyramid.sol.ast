PragmaDirective
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "Pyramid"
   Source: "contract Pyramid {\r\n    address master;\r\n\r\n    address[] memberQueue;\r\n    uint queueFront;\r\n\r\n    event Joined(address memberNew);\r\n\r\n    modifier onlymaster { if (msg.sender == master) _; }\r\n\r\n    function Pyramid() {\r\n        master = msg.sender;\r\n        memberQueue.push(master);\r\n        queueFront = 0;\r\n    }\r\n\r\n    // triggers on simple payments, unfortunately it doesnt work to call join here (mentioned below)\r\n    function(){}\r\n\r\n    // NOTE: do not use a fallback function to call this, it will fail because send() is only allotted\r\n    // 2300 gas (hardcoded value), you actually have to call join() with enough gas to execute\r\n    function join() payable {\r\n        // accept more than .1 ether as a donation :)\r\n        require(msg.value >= 100 finney);\r\n\r\n        memberQueue.push(msg.sender);\r\n\r\n        if (memberQueue.length % 2 == 1) {\r\n            address memberToPay = memberQueue[queueFront];\r\n            queueFront += 1;\r\n\r\n            // pay the person next in line in the pyramid\r\n            // the contract will automatically keep the remainder\r\n            memberToPay.send(180 finney); // does NOT throw on fail(returns)\r\n        }\r\n\r\n        Joined(msg.sender);\r\n\r\n        // this might eat up all of the gas\r\n        if (msg.value > 100 finney) {\r\n            msg.sender.send(msg.value - 100 finney);\r\n        }\r\n    }\r\n\r\n    function withdrawFee() onlymaster {\r\n        master.transfer(this.balance);\r\n    }\r\n\r\n    function setMaster(address _master) onlymaster {\r\n        master = _master;\r\n    }\r\n\r\n}"
  VariableDeclaration "master"
     Type: address
     Source: "address master"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "memberQueue"
     Type: address[] storage ref
     Source: "address[] memberQueue"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "queueFront"
     Type: uint256
     Source: "uint queueFront"
    ElementaryTypeName uint
       Source: "uint"
  EventDefinition "Joined"
     Source: "event Joined(address memberNew);"
    ParameterList
       Source: "(address memberNew)"
      VariableDeclaration "memberNew"
         Type: address
         Source: "address memberNew"
        ElementaryTypeName address
           Source: "address"
  ModifierDefinition "onlymaster"
     Source: "modifier onlymaster { if (msg.sender == master) _; }"
    ParameterList
       Source: ""
    Block
       Source: "{ if (msg.sender == master) _; }"
      IfStatement
         Source: "if (msg.sender == master) _"
        BinaryOperation using operator ==
           Type: bool
           Source: "msg.sender == master"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier master
             Type: address
             Source: "master"
        PlaceholderStatement
           Source: "_"
  FunctionDefinition "Pyramid" - public
     Source: "function Pyramid() {\r\n        master = msg.sender;\r\n        memberQueue.push(master);\r\n        queueFront = 0;\r\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        master = msg.sender;\r\n        memberQueue.push(master);\r\n        queueFront = 0;\r\n    }"
      ExpressionStatement
         Source: "master = msg.sender"
        Assignment using operator =
           Type: address
           Source: "master = msg.sender"
          Identifier master
             Type: address
             Source: "master"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Source: "memberQueue.push(master)"
        FunctionCall
           Type: uint256
           Source: "memberQueue.push(master)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "memberQueue.push"
            Identifier memberQueue
               Type: address[] storage ref
               Source: "memberQueue"
          Identifier master
             Type: address
             Source: "master"
      ExpressionStatement
         Source: "queueFront = 0"
        Assignment using operator =
           Type: uint256
           Source: "queueFront = 0"
          Identifier queueFront
             Type: uint256
             Source: "queueFront"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "" - public
     Source: "function(){}"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{}"
  FunctionDefinition "join" - public
     Source: "function join() payable {\r\n        // accept more than .1 ether as a donation :)\r\n        require(msg.value >= 100 finney);\r\n\r\n        memberQueue.push(msg.sender);\r\n\r\n        if (memberQueue.length % 2 == 1) {\r\n            address memberToPay = memberQueue[queueFront];\r\n            queueFront += 1;\r\n\r\n            // pay the person next in line in the pyramid\r\n            // the contract will automatically keep the remainder\r\n            memberToPay.send(180 finney); // does NOT throw on fail(returns)\r\n        }\r\n\r\n        Joined(msg.sender);\r\n\r\n        // this might eat up all of the gas\r\n        if (msg.value > 100 finney) {\r\n            msg.sender.send(msg.value - 100 finney);\r\n        }\r\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    Block
       Source: "{\r\n        // accept more than .1 ether as a donation :)\r\n        require(msg.value >= 100 finney);\r\n\r\n        memberQueue.push(msg.sender);\r\n\r\n        if (memberQueue.length % 2 == 1) {\r\n            address memberToPay = memberQueue[queueFront];\r\n            queueFront += 1;\r\n\r\n            // pay the person next in line in the pyramid\r\n            // the contract will automatically keep the remainder\r\n            memberToPay.send(180 finney); // does NOT throw on fail(returns)\r\n        }\r\n\r\n        Joined(msg.sender);\r\n\r\n        // this might eat up all of the gas\r\n        if (msg.value > 100 finney) {\r\n            msg.sender.send(msg.value - 100 finney);\r\n        }\r\n    }"
      ExpressionStatement
         Source: "require(msg.value >= 100 finney)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= 100 finney)"
          Identifier require
             Type: function (bool)
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 100 finney"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 100
               Type: int_const 100000000000000000
               Source: "100 finney"
      ExpressionStatement
         Source: "memberQueue.push(msg.sender)"
        FunctionCall
           Type: uint256
           Source: "memberQueue.push(msg.sender)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "memberQueue.push"
            Identifier memberQueue
               Type: address[] storage ref
               Source: "memberQueue"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (memberQueue.length % 2 == 1) {\r\n            address memberToPay = memberQueue[queueFront];\r\n            queueFront += 1;\r\n\r\n            // pay the person next in line in the pyramid\r\n            // the contract will automatically keep the remainder\r\n            memberToPay.send(180 finney); // does NOT throw on fail(returns)\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "memberQueue.length % 2 == 1"
          BinaryOperation using operator %
             Type: uint256
             Source: "memberQueue.length % 2"
            MemberAccess to member length
               Type: uint256
               Source: "memberQueue.length"
              Identifier memberQueue
                 Type: address[] storage ref
                 Source: "memberQueue"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Block
           Source: "{\r\n            address memberToPay = memberQueue[queueFront];\r\n            queueFront += 1;\r\n\r\n            // pay the person next in line in the pyramid\r\n            // the contract will automatically keep the remainder\r\n            memberToPay.send(180 finney); // does NOT throw on fail(returns)\r\n        }"
          VariableDeclarationStatement
             Source: "address memberToPay = memberQueue[queueFront]"
            VariableDeclaration "memberToPay"
               Type: address
               Source: "address memberToPay"
              ElementaryTypeName address
                 Source: "address"
            IndexAccess
               Type: address
               Source: "memberQueue[queueFront]"
              Identifier memberQueue
                 Type: address[] storage ref
                 Source: "memberQueue"
              Identifier queueFront
                 Type: uint256
                 Source: "queueFront"
          ExpressionStatement
             Source: "queueFront += 1"
            Assignment using operator +=
               Type: uint256
               Source: "queueFront += 1"
              Identifier queueFront
                 Type: uint256
                 Source: "queueFront"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
          ExpressionStatement
             Source: "memberToPay.send(180 finney)"
            FunctionCall
               Type: bool
               Source: "memberToPay.send(180 finney)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "memberToPay.send"
                Identifier memberToPay
                   Type: address
                   Source: "memberToPay"
              Literal, token: [no token] value: 180
                 Type: int_const 180000000000000000
                 Source: "180 finney"
      ExpressionStatement
         Source: "Joined(msg.sender)"
        FunctionCall
           Type: tuple()
           Source: "Joined(msg.sender)"
          Identifier Joined
             Type: function (address) constant
             Source: "Joined"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (msg.value > 100 finney) {\r\n            msg.sender.send(msg.value - 100 finney);\r\n        }"
        BinaryOperation using operator >
           Type: bool
           Source: "msg.value > 100 finney"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 100
             Type: int_const 100000000000000000
             Source: "100 finney"
        Block
           Source: "{\r\n            msg.sender.send(msg.value - 100 finney);\r\n        }"
          ExpressionStatement
             Source: "msg.sender.send(msg.value - 100 finney)"
            FunctionCall
               Type: bool
               Source: "msg.sender.send(msg.value - 100 finney)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "msg.sender.send"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "msg.value - 100 finney"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Literal, token: [no token] value: 100
                   Type: int_const 100000000000000000
                   Source: "100 finney"
  FunctionDefinition "withdrawFee" - public
     Source: "function withdrawFee() onlymaster {\r\n        master.transfer(this.balance);\r\n    }"
    ParameterList
       Source: "()"
    ParameterList
       Source: ""
    ModifierInvocation "onlymaster"
       Source: "onlymaster"
      Identifier onlymaster
         Type: modifier ()
         Source: "onlymaster"
    Block
       Source: "{\r\n        master.transfer(this.balance);\r\n    }"
      ExpressionStatement
         Source: "master.transfer(this.balance)"
        FunctionCall
           Type: tuple()
           Source: "master.transfer(this.balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "master.transfer"
            Identifier master
               Type: address
               Source: "master"
          MemberAccess to member balance
             Type: uint256
             Source: "this.balance"
            Identifier this
               Type: contract Pyramid
               Source: "this"
  FunctionDefinition "setMaster" - public
     Source: "function setMaster(address _master) onlymaster {\r\n        master = _master;\r\n    }"
    ParameterList
       Source: "(address _master)"
      VariableDeclaration "_master"
         Type: address
         Source: "address _master"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: ""
    ModifierInvocation "onlymaster"
       Source: "onlymaster"
      Identifier onlymaster
         Type: modifier ()
         Source: "onlymaster"
    Block
       Source: "{\r\n        master = _master;\r\n    }"
      ExpressionStatement
         Source: "master = _master"
        Assignment using operator =
           Type: address
           Source: "master = _master"
          Identifier master
             Type: address
             Source: "master"
          Identifier _master
             Type: address
             Source: "_master"
